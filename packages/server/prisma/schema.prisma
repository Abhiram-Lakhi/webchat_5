generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String            @id @default(cuid())
  role                 String            @default("user")
  displayName          String
  email                String?           @unique
  createdAt            DateTime          @default(now())
  sessions             Session[]
  assignments          AgentAssignment[]
  handoffsAccepted     HandoffRequest[]  @relation("UserAcceptedHandoffs")
  endRequestsAccepted  EndChatRequest[]  @relation("UserAcceptedEndRequests")
  // NEW: opposite side of SessionSummary.user
  sessionSummaries     SessionSummary[]
}

model Session {
  id          String           @id @default(cuid())
  status      String           @default("bot_pending")
  user        User?            @relation(fields: [userId], references: [id])
  userId      String?
  createdAt   DateTime         @default(now())
  closedAt    DateTime?
  messages    Message[]
  handoffs    HandoffRequest[]
  assignments AgentAssignment[]
  endRequests EndChatRequest[] @relation("SessionEndRequests")
  summary     SessionSummary?
}

model Message {
  id         String   @id @default(cuid())
  session    Session  @relation(fields: [sessionId], references: [id])
  sessionId  String
  senderType String
  senderId   String?
  text       String
  createdAt  DateTime @default(now())

  @@index([sessionId, createdAt])
  @@index([sessionId, id])
}


model HandoffRequest {
  id           String   @id @default(cuid())
  session      Session  @relation(fields: [sessionId], references: [id])
  sessionId    String
  requestedAt  DateTime @default(now())
  acceptedAt   DateTime?
  acceptedById String?
  acceptedBy   User?    @relation("UserAcceptedHandoffs", fields: [acceptedById], references: [id])
}

model AgentAssignment {
  id         String   @id @default(cuid())
  agent      User     @relation(fields: [agentId], references: [id])
  agentId    String
  session    Session  @relation(fields: [sessionId], references: [id])
  sessionId  String
  assignedAt DateTime @default(now())
  endedAt    DateTime?
}

model EndChatRequest {
  id           String   @id @default(cuid())
  session      Session  @relation("SessionEndRequests", fields: [sessionId], references: [id])
  sessionId    String
  requestedAt  DateTime @default(now())
  requestedBy  String   // 'user' | 'agent'
  acceptedAt   DateTime?
  declinedAt   DateTime?
  acceptedById String?
  acceptedBy   User?    @relation("UserAcceptedEndRequests", fields: [acceptedById], references: [id])
  status       String   @default("pending") // pending | accepted | declined

  @@index([sessionId, status])
}

model SessionSummary {
  id               String   @id @default(cuid())
  session          Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId        String   @unique
  user             User?    @relation(fields: [userId], references: [id])
  userId           String?

  // Snapshots
  userDisplayName  String
  agentDisplayName String

  // Content
  summary          String
  topics           String[] // Postgres text[]
  messageCount     Int

  // Timing/meta
  startedAt        DateTime
  endedAt          DateTime
  endedBy          String
  endRequestedBy   String?

  // Raw JSON copy of the full entry
  raw              Json

  createdAt        DateTime @default(now())

  @@index([userId, createdAt])
}
